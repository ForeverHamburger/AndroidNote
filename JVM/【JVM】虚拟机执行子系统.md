# 【JVM】类文件结构

代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。

Java 虚拟机不与包括 Java 语言在内的任何程序语言绑定，它只与“Class 文件”这种特定的二进制文件格式所关联，Class 文件中包含了 Java 虚拟机指令集、符号表以及若干其他辅助信息。

# 【JVM】虚拟机类加载机制

![image-20250418010634077](https://gitee.com/ForeverHamburger/picgo_imgs1/raw/master/202504180106188.png)

加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定特性（也称为动态绑定或晚期绑定）。

## 类加载时机

有六种情况必须立刻对类进行初始化：

> 遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。
>
> 能够生成这四条指令的典型Java 代码场景有：
>
> ·使用 new 关键字实例化对象的时候。
>
> ·读取或设置一个类型的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候。
>
> ·调用一个类型的静态方法的时候。

2) 使用 java.lang.reflect 包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。

3) 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

4) 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main()方法的那个类），虚拟机会先初始化这个主类。
5) 当使用 JDK 7 新加入的动态语言支持时
6) 当一个接口中定义了 JDK 8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

> 这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。

1. 通过子类引用父类的静态字段
2. 通过数组定义来引用类，不会触发此类的初始化
3. 常量在编译阶段会存入调用类的常量池中，本质上没有引用到定义常量的类，因此不会触发定义常量的类的初始化。

## 类加载过程

### 加载

在加载阶段，Java 虚拟机需要完成以下三件事情：

> 1) 通过一个类的全限定名来获取定义此类的二进制字节流。
> 2) 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
> 3) 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。

### 验证

验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求。

![image-20250420014355042](https://gitee.com/ForeverHamburger/picgo_imgs1/raw/master/202504200143104.png)

> 符号引用验证判断：
>
> 1. 符号引用中通过**字符串**描述的**全限定名**是否能够找到**对应的类**。
> 2. 在指定类中是否存在符合方法的**字段描述符**以及**简单名称**所描述的**方法**和**字段**。
> 3. 符号引用中的类、字段、方法的访问性（`private`、`protected`、`public`、`default`）**是否可被当前类访问**。

### 准备

准备阶段是正式为类中定义的变量（即静态变量，被 static 修饰的变量）分配内存并设置类变量初始值的阶段。

关于准备阶段，还有两个容易产生混淆的概念笔者需要着重强调，首先是这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。

> 避免混淆：
>
> 其次是这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为
>
> `public static int value = 123;`
>
> 那变量 value 在准备阶段过后的初始值为 0 而不是 123，因为这时尚未开始执行任何Java 方法，而把 value 赋值为 123 的 putstatic 指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把 value 赋值为 123 的动作要到类的初始化阶段才会被执行。

上面提到在“通常情况”下初始值是零值，那言外之意是相对的会有某些“特殊情况”：如果类字段的字段属性表中存在 ConstantValue 属性，那在准备阶段变量值就会被初始化为 ConstantValue 属性所指定的初始值，假设上面类变量 value 的定义修改为：

public static final int value = 123;

编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据Con-stantValue 的设置将 value 赋值为 123。

### 解析

解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程。

> ·符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java 虚拟机规范》的 Class 文件格式中。
>
> ·直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。



### 初始化

类的初始化阶段是类加载过程的最后一个步骤，之前介绍的几个类加载的动作里，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由 Java 虚拟机来主导控制。直到初始化阶段，Java 虚拟机才真正开始执行类中编写的 Java 程序代码，将主导权移交给应用程序。

在初始化阶段，会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。

初始化阶段就是执行类构造器<clinit>()方法的过程。

·<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的。

·<clinit>()方法与类的构造函数（即在虚拟机视角中的实例构造器<init>()方法）不同，它不需要显式地调用父类构造器，Java 虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。



## 类加载器

Java 虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”

### 类与类加载器

类加载器虽然只用于实现类的加载动作，但它在 Java 程序中起到的作用却远超类加载阶段。

对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。

### 双亲委派模型

站在 Java 虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用 C++语言实现，是虚拟机自身的一部分；另外一种就是其他所有的类加载器，这些类加载器都由 Java 语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。

![image-20250420195551902](https://gitee.com/ForeverHamburger/picgo_imgs1/raw/master/202504201955016.png)

> **启动类加载器（BootScrapClassLoader）**
>
> - **加载Java核心类，用C++代码编写，无法直接访问**
>
> - 负责加载JRE核心库(rt.jar等)以及其他核心类库。这些类库是由本地代码实现的，无法在Java中访问它们。
>
> - 启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器去处理，那直接使用null代替即可。

> **拓展类加载器（ExtensionClassLoader）**
>
> - 它是一种Java系统类库的拓展机制，可以将通用性的类库放置在ext目录里以拓展Java SE的功能，在JDK 9之后被模块化带来的天然的拓展功能代替。

> **应用程序类加载器（AppClassLoader）**
>
> - 这个类加载器由sun.misc.Launcher$AppClassLoader来实现的。
> - 由于应用程序类加载器是ClassLoader类中的getSystemClassLoader()方法的返回值，所以也可以称他为系统类加载器。
> - 他负责加载用户类路径上所有的类库，开发者也可以直接在代码中使用这个类加载器。（**加载当前应用**`classpath`下的jar包和类，是直接面向用户的加载器。）

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

> 优点：
>
> - 防止`java核心类`、`API`被开发者覆盖或篡改，比如我们自定义了Object类，并定义加载器为自定义加载器。这时就会使得系统有多个同名类。使用双亲委派模型，无论我们在怎样的类加载环境中，像Object类永远都是由BootScrapClassLoader（启动类加载器）加载。
>
> - **避免一个类的重复加载**（JVM 区分不同类的方式不仅仅是根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类）。

### 破坏双亲委派模型

**自定义类加载器重写**` loadClass() `方法，自己加载本类，让父类加载器去加载object类。

- **不打破双亲委派模型**：自定义加载器的话，需要继承 `ClassLoader` ，就重写 ClassLoader 类中的 `findClass() `方法即可。无法被父类加载器加载的类最终会通过 findClass() 方法被加载。

**使用线程上下文加载器。**

- 线程上下文加载器其实是一种类加载传递机制。可以通过`java.lang.Thread#setContextClassLoader`方法给一个线程设置上下文类加载器，在该线程后续执行过程中就能把这个类加载器取出来使用。



# 【JVM】虚拟机字节码执行引擎

## 运行时栈帧结构

栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。

在编译 Java 程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的 Code 属性之中。

### 局部变量表

局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。

![image-20250420203029882](https://gitee.com/ForeverHamburger/picgo_imgs1/raw/master/202504202030938.png)

### 操作数栈

操作数栈（Operand Stack）也常被称为操作栈，它是一个后入先出（Last In First Out，LIFO）栈。

当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。

### 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。
