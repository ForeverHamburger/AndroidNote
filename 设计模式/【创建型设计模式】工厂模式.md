# 【创建型设计模式】工厂模式

# 简单工厂模式

简单工厂模式（又叫作静态工厂方法模式），其属于创建型设计模式，但是并不属于23种GoF设计模式之一。提到它是为了让大家能够更好地理解后面讲到的工厂方法模式。 定义：简单工厂模式属于创建型设计模式，其又被称为静态工厂方法模式，这是由一个工厂对象决定创建出哪一种产品类的实例。

<img src="https://gitee.com/ForeverHamburger/picgo_imgs1/raw/master/202411240029259.png" alt="image-20241124002908197" style="zoom: 80%;" />

在简单工厂模式中有如下角色：

- Factory: 工厂类，这是简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。
- Product: 抽象产品类，这是简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。
- Product: 具体产品类，这是简单工厂模式的创建目标。

## 1. 简单工厂模式的简单实现

这里我们用生产计算机来举例，假设有一个计算机的代工生产商，它目前已经可以代工生产联想计算机了。随着业务的拓展，这个代工生产商还要生产惠普和华硕的计算机。这样我们就需用一个单独的类来专门生产计算机，这就用到了简单工厂模式，下面我们来实现简单工厂模式。

#### （1）抽象产品类

我们创建一个计算机的抽象产品类，其有一个抽象方法用于启动计算机，如下所示：

```java
public abstract class Computer {
    /**
     * 产品的抽象方法，由具体产品类实现
     */
    public abstract void start();
}
```

#### （2）具体产品类

接着我们创建各个品牌的计算机，其都继承了自己的父类Computer，并实现了父类的start方法，具体的计算机产品分别是联想计算机、惠普计算机和华硕计算机：

```java
public class LenovoComputer extends Computer {
    @Override
    public void start() {
        System.out.println("联想计算机启动");
    }
}

public class HpComputer extends Computer {
    @Override
    public void start() {
        System.out.println("惠普计算机启动");
    }
}

public class AsusComputer extends Computer {
    @Override
    public void start() {
        System.out.println("华硕计算机启动");
    }
}
```

#### （3）工厂类

接下来创建一个工厂类，它提供了一个静态方法createComputer来生产计算机。你只需要传入自己要生产的计算机的品牌，它就会实例化相应品牌的计算机对象，代码如下所示：

```java
public class ComputerFactory {
    public static Computer createComputer(String type) {
        Computer mComputer = null;

        switch (type) {
            case "lenovo":
                mComputer = new LenovoComputer();
                break;
            case "hp":
                mComputer = new HpComputer();
                break;
            case "asus":
                mComputer = new AsusComputer();
                break;
        }
        return mComputer;
    }
}
```

#### （4）客户端调用工厂类

客户端调用工厂类，传入"hp"生产出惠普计算机并调用该计算机对象的start方法，如下所示：

```java
public class CreateComputer {
    public static void main(String[] args) {
        ComputerFactory.createComputer("hp").start();
    }
}
```

## 2. 使用简单工厂模式的场景和优缺点

- 工厂类负责创建的对象比较少。
- 客户只需知道传入工厂类的参数，而无须关心创建对象的逻辑。
- 优点：使用户根据参数获得对应的类实例，避免了直接实例化类，降低了耦合性。
- 缺点：可实例化的类在编译期间已经被确定。如果增加新类型，则需要修改工厂，这违背了开放封闭原则。使用简单工厂模式时需要知道所有要生成的类型，当子类过多或者子类层次过多时不适合使用简单工厂模式。

# 工厂方法模式

定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。

在工厂方法模式中有如下角色：

- Product：抽象产品类。
- ConcreteProduct：具体产品类，实现Product接口。
- Factory：抽象工厂类，该方法返回一个Product类型的对象。
- ConcreteFactory：具体工厂类，返回ConcreteProduct实例。

<img src="https://gitee.com/ForeverHamburger/picgo_imgs1/raw/master/202411240037653.png" alt="image-20241124003745585" style="zoom: 80%;" />

### 工厂方法模式的简单实现

工厂方法模式的抽象产品类与具体产品类的创建和简单工厂模式是一样的。

#### （1）创建抽象工厂

抽象工厂里面有一个createComputer方法，想生产哪个品牌的计算机就生产哪个品牌的，如下所示：

```java
public abstract class ComputerFactory {
    public abstract <T extends Computer> T createComputer(Class<T> cls);
}
```

#### （2）创建具体工厂

广达代工厂是一个具体的工厂，其继承自抽象工厂，通过反射来生产不同厂家的计算机：

```java
public class GDComputerFactory extends ComputerFactory {
    @Override
    public <T extends Computer> T createComputer(Class<T> cls) {
        Computer computer = null;
        String className = cls.getName();
        try {
            // 通过反射来生产不同厂家的计算机
            computer = (Computer) Class.forName(className).newInstance();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return (T) computer;
    }
}
```

#### （3）客户端调用

客户端创建了GDComputerFactory，并分别生产了联想计算机、惠普计算机和华硕计算机：

```java
public class Client {
    public static void main(String[] args) {
        ComputerFactory factory = new GDComputerFactory();
        LenovoComputer mLenovoComputer = factory.createComputer(LenovoComputer.class);
        mLenovoComputer.start();
        HpComputer mHpComputer = factory.createComputer(HpComputer.class);
        mHpComputer.start();
        AsusComputer mAsusComputer = factory.createComputer(AsusComputer.class);
        mAsusComputer.start();
    }
}
```

### 工厂方法模式与简单工厂模式

对于简单工厂模式，我们都知道其在工厂类中包含了必要的逻辑判断，根据不同的参数来动态实例化相应的类。对客户端来说，这去除了与具体产品的依赖；但与此同时也会带来一个问题：如果要增加产品，比如我们要生产苹果计算机，就需要在工厂类中添加一个Case分支条件，这违背了开放封闭原则，修改也开放了。而工厂方法模式就没有违背这个开放封闭原则。如果我们需要生产苹果计算机，则无须修改工厂类，直接创建工厂类即可。
